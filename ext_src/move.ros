#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp(ql:quickload '() :silent t)
  )

(defpackage :ros.script.move.3854806605
  (:use :cl))
(in-package :ros.script.move.3854806605)

(require :sb-cltl2)
(require :uiop)
(require :asdf)
(require :cl-ppcre)
;; (require :fiveam)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (cat cont) を ^cont.cat みたいに書くためのマクロ
;;
;; https://sile.hatenablog.jp/entry/20090628/1246187355

(defun decompose-fn (sym)
  (mapcar #'intern (cl-ppcre:split "@" (string sym))))

(defun get-fn (sym)
  (car (decompose-fn sym)))

(defun get-fnargs (sym)
  (cdr (decompose-fn sym)))

;; ドット表記の関数呼び出しを、S式に変換
;; ^arg2.fn@arg1 のような表記ができるように拡張
(defun read-dot-exprs (stream)
  (reduce (lambda (arg fn) (if (get-fnargs fn)
			       (append (cons (get-fn fn) (get-fnargs fn)) (list arg))
			     (list (get-fn fn) arg)))
	  (mapcar #'intern
		  (cl-ppcre:split "\\." (symbol-name (read stream))))))
  
;; オリジナル
;; (defun read-dot-exprs (stream)
;;   (reduce (lambda (arg fn) `(,fn ,arg))
;; 	  (mapcar #'intern
;; 		  (split-by-char #\. (symbol-name (read stream))))))
;; )

;; リードマクロ読み込み
(set-macro-character #\^
  (lambda (stream c)
    (declare (ignore c))
    (read-dot-exprs stream)
  )
)
  
;; <name>__comp=1.root がラベルであるノードを変更
;; → move-comp1をかぶせる．
;;   そのうえで，ノードに+をつける．
(defmacro defmacro_s_comp=1 (stype)
  (let* ( (node-label (intern (concatenate 'string stype "__comp=1.root")))
	        (node-label-new 
              (intern (concatenate 'string stype "__comp=1.root+"))
          )
        )
    `(defmacro ,node-label (&rest childs)
       `(move-comp1 (,',node-label-new ,@childs))
    )
  )
)

;; <name>__comp=1.root がラベルであるノードをマクロとして定義する
(defmacro_s_comp=1 "Sa")
(defmacro_s_comp=1 "Se")
(defmacro_s_comp=1 "Sm")
(defmacro_s_comp=1 "Srel")
(defmacro_s_comp=1 "Ssub")

;; <name>__comp=1.root__deriv=<dir> がラベルであるノードを変更
;; → move-comp1をかぶせる．
;;   そのうえで，ノードに+をつける．
(defmacro defmacro_s_comp=1_alt (stype rule_name)
  (let* ( (node-label
            (intern (concatenate 'string stype "__comp=1.root" rule_name))
          )
          (node-label-new 
            (intern (concatenate 'string stype "__comp=1.root+" rule_name))
          )
        )
    `(defmacro ,node-label (&rest childs)
       `(move-comp1 (,',node-label-new ,@childs)))))

;; <name>__comp=1.root__deriv=<dir> がラベルであるノードをマクロとして定義する
(defmacro_s_comp=1_alt "Sa" "__deriv=>")
(defmacro_s_comp=1_alt "Se" "__deriv=>")
(defmacro_s_comp=1_alt "Sm" "__deriv=>")
(defmacro_s_comp=1_alt "Srel" "__deriv=>")
(defmacro_s_comp=1_alt "Ssub" "__deriv=>")

(defmacro_s_comp=1_alt "Sa" "__deriv=<")
(defmacro_s_comp=1_alt "Se" "__deriv=<")
(defmacro_s_comp=1_alt "Sm" "__deriv=<")
(defmacro_s_comp=1_alt "Srel" "__deriv=<")
(defmacro_s_comp=1_alt "Ssub" "__deriv=<")

(defmacro move-comp1 (s)
  (let*     ( (cont (car (find-nodes "comp=1\.cont" s)))
              (prej (car (find-nodes "comp=1\.prej" s)))
              (diff (car (find-nodes "comp=1\.diff" s)))
              (diff-mvd 
                (if diff 
                    (relabel "DEG__deriv=unary-unknown__comp=1.diff" diff)
                )
              )
              (prej-mvd
                (if diff 
                    (relabel-prej-with-diff
                        prej diff
                        (if cont (vs ^s.cat ^cont.cat) ^s.cat)
                        "__deriv=|<__comp=1.prej"
                    )
                    (relabel-prej-no-diff
                        prej
                        (if cont (vs ^s.cat ^cont.cat) ^s.cat)
                        "__deriv=|<__comp=1.prej"
                    )
                )
              )
            )
    ;; 元の木の上に抽出されたcont prej diffを重ねる
    (reduce 
      #'(lambda (base filler)
          (let ( (result-cat
                    (cond 
                        (^filler.contp 
                            (+s ^s.cat "__deriv=|<__comp=1.cont.moved")
                        )
                        (^filler.prejp 
                            (+s 
                              (reduce #'vs 
                                      (clist ^cont.cat ^diff-mvd.cat)
                                      :initial-value ^s.cat
                              )
                              "__deriv=|>__comp=1.prej.moved"
                            )
                        )
                        (^filler.diffp 
                            (+s 
                              (reduce #'vs 
                                      (clist ^cont.cat)
                                      :initial-value ^s.cat
                              )
                              "__deriv=|<__comp=1.diff.moved"
                            )
                        )
                    )
                  )
              )
          (merge-trees result-cat filler base)
        ) ;; end let result-cat
      ) ;; end #'lambda
	    (clist prej-mvd diff-mvd cont)
	    :initial-value 
          ;; 元の木のconj，prej，diffをtraceとして抜く．
          (reduce #'remove-and-bind0 (clist cont prej diff) :initial-value s)
    ) ;; end reduce
  )
)

(defun contp (tree)
  (equal ^tree.filler-type "cont"))

(defun prejp (tree)
  (equal ^tree.filler-type "prej"))

(defun diffp (tree)
  (equal ^tree.filler-type "diff"))

(defun treep (sexp)
  (or (symbolp sexp)
      (numberp sexp)
      (and  (symbolp (car sexp))
            (let  ( (l (mapcar #'treep (cdr sexp))))
                  (and l (not (member nil l)))
            )
      )
  )
)

(defun truep (x) (not (not x)))

(defun bind (cat type tree)
  (let* ( (newcat (vs ^tree.cat cat))
          (suffix (concatenate 'string "__comp=1." type ".bind"))
          (newlabel (+s newcat suffix))
        )
    `(,newlabel ,tree)
  ) 
)

(defun merge-trees (cat left-tree right-tree)
  (if left-tree
      `(,cat ,left-tree ,right-tree)
      right-tree
  )
)

(defun remove-and-bind (cat type tree)
  (let* ( (tag (concatenate 'string "comp=1." type))
          (trace (make-trace cat type))
        )
    (bind cat type (replace-nodes tag trace tree))
  )
)

(defun remove-and-bind0 (tree subtree)
  (remove-and-bind ^subtree.cat ^subtree.filler-type tree))

(defun filler-type (tree)
  (cl-ppcre:regex-replace "__deriv=.*$"
			  (cadr (cl-ppcre:split "\\." ^tree.get-suffix)) ""))

(defun make-trace (cat type)
  (list (intern (concatenate 'string cat "__comp=1." type))
        (intern (concatenate 'string "*TRACE-" type "1*"))
  )
)

(defun relabel-prej-with-diff (prej diff cont-bound-cat suffix)
  (let* ( (yori-p-cat 
            (vs (vs cont-bound-cat "DEG") 
                (vs2 cont-bound-cat ^prej.cat ^diff.cat)
            )
          )
          (yori-arg (cadr prej))
          (yori (caddr prej))
        )
  `(  ,(+s yori-p-cat suffix)
      ,yori-arg
      ,(relabel (vs yori-p-cat ^yori-arg.cat) yori))
  )
)

(defun relabel-prej-no-diff (prej cont-bound-cat suffix)
  (let* ( (yori-p-cat (vs cont-bound-cat (vs cont-bound-cat ^prej.cat)))
          (yori-arg (cadr prej))
          (yori (caddr prej))
        )
    `(  ,(+s yori-p-cat suffix)
        ,yori-arg
        ,(relabel (vs yori-p-cat ^yori-arg.cat) yori)
    )
  )
)

(defun vs (res arg)
  (concatenate 'string "<" res "|" arg ">"))

(defun vs2 (res arg1 arg2)
  (vs (vs res arg1) arg2))

(defun add-suffix (label str)
  (intern (concatenate 'string (string label) str)))

(defun +s (label str)
  (add-suffix label str))

(defun remove-suffix (label)
  (cl-ppcre:regex-replace "_.*$" label ""))

(defun remove-cat (label)
  (cl-ppcre:regex-replace "^.*?__" label ""))

(defun get-label (tree)
  (if (and tree ^tree.listp) ^tree.car.string.remove-suffix))

(defun cat (tree)
  ^tree.get-label)

(defun get-suffix (tree)
  (if ^tree.listp ^tree.car.string.remove-cat))

(defun relabel (label tree)
  (if ^tree.listp (cons ^label.intern ^tree.cdr)))

  
(defun flatten (list-of-lists) 
    (apply #'append list-of-lists))

(defun compact (list)
    (remove nil list))

(defun clist (&rest args)
    (remove nil args)) 
    

(defun find-nodes (label tree)
  "labelとマッチするtreeのサブツリーのリストを返す"
  (if (cl-ppcre:scan label ^tree.car.string)
      (list tree)
    ^tree.cdr.find-nodes-all@label))

(defun find-nodes-all (label trees)
  (flatten (compact (mapcar #'(lambda (x) (and ^x.listp
					       ^x.find-nodes@label)) trees))))

(defun remove-nodes (label tree)
  "treeからlabelとマッチするサブツリーを削除"
    (if (cl-ppcre:scan label ^tree.car.string) nil
      (cons ^tree.car (remove-nodes-all label ^tree.cdr))))

(defun remove-nodes-all (label trees)
  (mapcar #'(lambda (x) (if ^x.listp
			    ^x.remove-nodes@label
			  x))
	  trees))

(defun replace-nodes (label subtree tree)
  "treeのlabel位置にsubtreeを埋め込む"
  (if (cl-ppcre:scan label ^tree.car.string)
      subtree
    (cons ^tree.car (replace-nodes-all label subtree ^tree.cdr))))

(defun replace-nodes-all (label subtree trees)
  (mapcar #'(lambda (x) (if ^x.listp
			    ^x.replace-nodes@label@subtree
			  x))
	  trees))

;;読み込んだツリーをmacroexpandして書き出す
(defun main (&rest argv)
  ;; (with-open-file (in filename :direction :input)
  (let*         ( (filename-raw (cadr argv))
                  (r-table (copy-readtable *readtable*))
                  (trees '())
                  (trees-tail trees)
                )
    (setf (readtable-case r-table) :preserve)
    (let ( (*readtable* r-table))
        (loop
          (let            ( (buff (read *standard-input* nil) ))
              (if (not buff) (return))
              (cond 
                  ( (consp trees-tail)  
                    (setf (cdr trees-tail) (cons buff nil))
                    (setq trees-tail (cdr trees-tail) )
                  )
                  ( t
                    (setq trees (cons buff nil))
                    (setq trees-tail trees)
                  )
              )
          )
        )
    )
    (format *error-output* "# of loaded trees: ~d~%" (length trees) )
    (loop for x in trees do
          (princ (remove-if-not #'treep
                                (sb-cltl2:macroexpand-all x)
                  )
                 *standard-output*
          )
          (format *standard-output* "~%")
    )
  )
)
;;; vim: set ft=lisp lisp:
